"""
Pydantic models for the agent system.

Defines shared data structures for agent communication, state management,
and interpretive assertions.
"""

from datetime import datetime
from enum import Enum
from typing import Any

from pydantic import BaseModel, Field


# =============================================================================
# ENUMS
# =============================================================================


class AgentType(str, Enum):
    """Types of agents in the system."""

    ORCHESTRATOR = "orchestrator"
    GEO_ANALYZER = "geo_analyzer"
    TEMPORAL_ANALYZER = "temporal_analyzer"
    TYPE_ANALYZER = "type_analyzer"
    PATH_GENERATOR = "path_generator"
    TRIPLE_GENERATOR = "triple_generator"
    VALIDATOR = "validator"


class TaskStatus(str, Enum):
    """Status of an agent task."""

    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"


class AssertionType(str, Enum):
    """Types of interpretive assertions."""

    GEOGRAPHIC_CLUSTER = "geographic_cluster"
    CHRONOLOGICAL_CLUSTER = "chronological_cluster"
    TYPOLOGICAL_CLUSTER = "typological_cluster"
    NEAR_TO = "near_to"
    CONTEMPORARY_WITH = "contemporary_with"
    SIMILAR_TO = "similar_to"
    THEMATIC_PATH = "thematic_path"
    PATH_STOP = "path_stop"
    EXTRACTED_FEATURE = "extracted_feature"


class PathType(str, Enum):
    """Types of thematic paths - determines validation strategy."""

    GEOGRAPHIC = "geographic"  # Strict distance validation (max 200km)
    CHRONOLOGICAL = "chronological"  # Flexible: entities from same period, any distance
    TYPOLOGICAL = "typological"  # Flexible: similar entity types, any distance
    MIXED = "mixed"  # Flexible: combination of criteria


# =============================================================================
# AGENT TASK & RESULT
# =============================================================================


class AgentTask(BaseModel):
    """A task assigned to an agent by the orchestrator."""

    agent: AgentType = Field(description="Target agent for this task")
    task_id: str = Field(description="Unique task identifier")
    description: str = Field(description="Human-readable task description")
    params: dict[str, Any] = Field(default_factory=dict, description="Task parameters")
    priority: int = Field(default=1, ge=1, le=10, description="Task priority (1=low, 10=high)")
    created_at: datetime = Field(default_factory=datetime.now)


class AgentResult(BaseModel):
    """Result returned by an agent after completing a task."""

    agent: AgentType = Field(description="Agent that produced this result")
    task_id: str = Field(description="ID of the completed task")
    status: TaskStatus = Field(description="Task completion status")
    assertions: list["InterpretiveAssertion"] = Field(
        default_factory=list, description="Generated assertions"
    )
    metadata: dict[str, Any] = Field(default_factory=dict, description="Additional metadata")
    error: str | None = Field(default=None, description="Error message if failed")
    completed_at: datetime = Field(default_factory=datetime.now)


# =============================================================================
# INTERPRETIVE ASSERTIONS
# =============================================================================


class InterpretiveAssertion(BaseModel):
    """
    Base model for an interpretive assertion generated by an agent.

    Assertions are grounded in ArCo entities and will be converted to RDF triples.
    """

    assertion_id: str = Field(description="Unique assertion identifier")
    assertion_type: AssertionType = Field(description="Type of assertion")
    label: str = Field(description="Human-readable label")
    description: str | None = Field(default=None, description="Detailed description")

    # Grounding to ArCo entities
    subject_uris: list[str] = Field(
        default_factory=list, description="URIs of subject entities from ArCo"
    )
    object_uris: list[str] = Field(
        default_factory=list, description="URIs of object entities (for relations)"
    )

    # Provenance
    generated_by: AgentType = Field(description="Agent that generated this assertion")
    confidence_score: float = Field(ge=0.0, le=1.0, description="Confidence score (0.0-1.0)")
    reasoning: str | None = Field(default=None, description="Explanation of the assertion")

    # Metadata
    created_at: datetime = Field(default_factory=datetime.now)
    validated: bool = Field(default=False, description="Whether assertion has been validated")
    validation_notes: str | None = Field(default=None)


class GeographicCluster(InterpretiveAssertion):
    """A cluster of geographically proximate sites."""

    assertion_type: AssertionType = AssertionType.GEOGRAPHIC_CLUSTER

    centroid_lat: float | None = Field(default=None, description="Cluster centroid latitude")
    centroid_lon: float | None = Field(default=None, description="Cluster centroid longitude")
    radius_km: float | None = Field(default=None, description="Cluster radius in km")
    site_count: int = Field(default=0, description="Number of sites in cluster")
    region: str | None = Field(default=None, description="Geographic region name")


class ChronologicalCluster(InterpretiveAssertion):
    """A cluster of chronologically related sites."""

    assertion_type: AssertionType = AssertionType.CHRONOLOGICAL_CLUSTER

    period_label: str | None = Field(default=None, description="Period name")
    start_year: int | None = Field(default=None, description="Approximate start year (negative=BC)")
    end_year: int | None = Field(default=None, description="Approximate end year (negative=BC)")


class TypologicalCluster(InterpretiveAssertion):
    """A cluster of typologically similar sites."""

    assertion_type: AssertionType = AssertionType.TYPOLOGICAL_CLUSTER

    typology: str | None = Field(default=None, description="Typology category")
    shared_features: list[str] = Field(default_factory=list, description="Features shared by sites")


class SiteRelation(InterpretiveAssertion):
    """A relation between two sites (nearTo, contemporaryWith, similarTo)."""

    source_uri: str = Field(description="URI of the source site")
    target_uri: str = Field(description="URI of the target site")
    relation_value: float | None = Field(
        default=None, description="Relation value (e.g., distance in km)"
    )


class ExtractedFeatureAssertion(InterpretiveAssertion):
    """An extracted feature materialised as an independent assertion."""

    assertion_type: AssertionType = AssertionType.EXTRACTED_FEATURE

    feature_label: str = Field(description="Label of the extracted feature")
    feature_category: str = Field(
        description="Feature category: architectural, functional, contextual, material"
    )
    entity_uri: str = Field(description="URI of the entity this feature was extracted from")
    entity_name: str = Field(default="", description="Display name of the entity")


class ThematicPath(InterpretiveAssertion):
    """A thematic path connecting multiple sites."""

    assertion_type: AssertionType = AssertionType.THEMATIC_PATH

    theme: str = Field(description="Path theme")
    path_type: str = Field(
        default="mixed", description="Path type: geographic, chronological, typological, or mixed"
    )
    narrative: str | None = Field(default=None, description="Path narrative")
    estimated_duration: float | None = Field(
        default=None, description="Estimated duration in hours"
    )
    difficulty: str | None = Field(default=None, description="Path difficulty (easy, medium, hard)")
    stops: list["PathStop"] = Field(default_factory=list, description="Ordered stops")


class PathStop(InterpretiveAssertion):
    """A stop in a thematic path - extends InterpretiveAssertion."""

    assertion_type: AssertionType = AssertionType.PATH_STOP

    stop_id: str = Field(default="", description="Stop identifier")
    path_id: str = Field(description="ID of parent path")
    site_uri: str = Field(description="URI of the site")
    site_name: str = Field(default="", description="Name of the site")
    order: int = Field(ge=1, description="Stop order in the path")
    justification: str | None = Field(default=None, description="Why this stop is included")
    narrative: str | None = Field(default=None, description="Stop-specific narrative")

    def model_post_init(self, __context):
        """Auto-generate stop_id and site_name if not provided."""
        if not self.stop_id:
            self.stop_id = self.assertion_id
        if not self.site_name and self.label:
            # Extract site name from label if possible
            self.site_name = self.label.split(":")[-1].strip() if ":" in self.label else self.label


# =============================================================================
# AGENT STATE
# =============================================================================


class AgentState(BaseModel):
    """
    Current state of the multi-agent system.

    Passed between agents and updated throughout the workflow.
    """

    # Iteration tracking
    iteration: int = Field(default=0, description="Current iteration number")
    max_iterations: int = Field(default=20, description="Maximum iterations allowed")

    # Entity data
    entity_count: int = Field(default=0, description="Total number of entities")
    entities_processed: list[str] = Field(
        default_factory=list, description="URIs of processed entities"
    )

    # Generated assertions
    assertions: list[InterpretiveAssertion] = Field(
        default_factory=list, description="All generated assertions"
    )

    # Task history
    completed_tasks: list[str] = Field(default_factory=list, description="IDs of completed tasks")
    pending_tasks: list[AgentTask] = Field(
        default_factory=list, description="Tasks waiting to be executed"
    )

    # Analysis flags (track which analyses have been performed)
    geo_analysis_done: bool = Field(default=False)
    temporal_analysis_done: bool = Field(default=False)
    type_analysis_done: bool = Field(default=False)
    path_generation_done: bool = Field(default=False)

    # Errors and messages
    errors: list[str] = Field(default_factory=list, description="Error messages")
    messages: list[str] = Field(default_factory=list, description="Status messages")

    # Timestamps
    started_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)

    def add_assertion(self, assertion: InterpretiveAssertion) -> None:
        """Add an assertion to the state."""
        self.assertions.append(assertion)
        self.updated_at = datetime.now()

    def add_message(self, message: str) -> None:
        """Add a status message."""
        self.messages.append(f"[{datetime.now().isoformat()}] {message}")
        self.updated_at = datetime.now()

    def add_error(self, error: str) -> None:
        """Add an error message."""
        self.errors.append(f"[{datetime.now().isoformat()}] {error}")
        self.updated_at = datetime.now()

    def should_terminate(self) -> bool:
        """Check if the workflow should terminate."""
        # Max iterations reached
        if self.iteration >= self.max_iterations:
            return True
        # All analyses completed
        if (
            self.geo_analysis_done
            and self.temporal_analysis_done
            and self.type_analysis_done
            and self.path_generation_done
        ):
            return True
        return False

    def get_summary(self) -> dict[str, Any]:
        """Return a summary of the current state."""
        return {
            "iteration": self.iteration,
            "entity_count": self.entity_count,
            "assertions_count": len(self.assertions),
            "completed_tasks": len(self.completed_tasks),
            "geo_done": self.geo_analysis_done,
            "temporal_done": self.temporal_analysis_done,
            "type_done": self.type_analysis_done,
            "path_done": self.path_generation_done,
            "errors": len(self.errors),
        }


# =============================================================================
# LLM STRUCTURED OUTPUT MODELS
# =============================================================================
# These models define the expected JSON structure from LLM responses.
# Used with LangChain's `with_structured_output()` for reliable parsing.


class GeoClusterProposal(BaseModel):
    """LLM proposal for a geographic cluster."""

    cluster_label: str = Field(
        description="Descriptive name for the cluster (e.g., 'Cluster megalitico della Murgia')"
    )
    member_uris: list[str] = Field(description="URIs of entities belonging to this cluster")
    region: str | None = Field(default=None, description="Geographic region or territory")
    reasoning: str = Field(description="Explanation of why these sites form a cluster")
    llm_confidence: float = Field(ge=0.0, le=1.0, description="LLM's confidence in this proposal")


class NearRelationProposal(BaseModel):
    """LLM proposal for a nearTo relation between sites."""

    source_uri: str = Field(description="URI of the first site")
    target_uri: str = Field(description="URI of the second site")
    spatial_context: str = Field(description="Description of the spatial relationship")
    reasoning: str = Field(description="Why this proximity is significant")
    llm_confidence: float = Field(ge=0.0, le=1.0)


class GeoAnalysisResponse(BaseModel):
    """Complete structured response from GeoSpatialAgent LLM call."""

    clusters: list[GeoClusterProposal] = Field(
        default_factory=list, description="Proposed geographic clusters"
    )
    relations: list[NearRelationProposal] = Field(
        default_factory=list, description="Proposed nearTo relations"
    )
    territorial_observations: str = Field(
        default="", description="General observations about territorial distribution"
    )


class PeriodNormalization(BaseModel):
    """LLM normalization of a chronological period label."""

    original_label: str = Field(description="Original period label from the data")
    normalized_period: str = Field(
        description="Standardized period name (e.g., 'Bronze Age', 'Neolithic')"
    )
    start_year: int | None = Field(
        default=None, description="Approximate start year (negative = BC)"
    )
    end_year: int | None = Field(default=None, description="Approximate end year (negative = BC)")
    confidence: float = Field(ge=0.0, le=1.0, description="Confidence in the normalization")


class ChronoClusterProposal(BaseModel):
    """LLM proposal for a chronological cluster."""

    period_label: str = Field(description="Period name for this cluster")
    member_uris: list[str] = Field(description="URIs of entities in this chronological group")
    temporal_narrative: str = Field(description="Narrative about this chronological phase")
    start_year: int | None = Field(default=None, description="Period start year")
    end_year: int | None = Field(default=None, description="Period end year")
    reasoning: str = Field(description="Explanation of the grouping")
    llm_confidence: float = Field(ge=0.0, le=1.0)


class ContemporaryPairProposal(BaseModel):
    """LLM proposal for a contemporaryWith relation."""

    source_uri: str = Field(description="URI of the first site")
    target_uri: str = Field(description="URI of the second site")
    shared_period: str = Field(description="The period they share")
    reasoning: str = Field(description="Why these sites are considered contemporary")
    llm_confidence: float = Field(ge=0.0, le=1.0)


class ChronologicalAnalysisResponse(BaseModel):
    """Complete structured response from ChronologicalAgent LLM call."""

    normalizations: list[PeriodNormalization] = Field(
        default_factory=list, description="Period normalizations"
    )
    clusters: list[ChronoClusterProposal] = Field(
        default_factory=list, description="Chronological clusters"
    )
    contemporary_pairs: list[ContemporaryPairProposal] = Field(
        default_factory=list, description="Contemporary relations"
    )
    chronological_narrative: str = Field(default="", description="Overall chronological narrative")


class ExtractedFeatures(BaseModel):
    """LLM extraction of features from an entity's textual description."""

    entity_uri: str = Field(description="URI of the analyzed entity")
    architectural_features: list[str] = Field(
        default_factory=list, description="E.g., corridor, single chamber, gallery"
    )
    functional_features: list[str] = Field(
        default_factory=list, description="E.g., funerary, cultic, settlement"
    )
    contextual_features: list[str] = Field(
        default_factory=list, description="E.g., rural, rocky, hilltop"
    )
    material_features: list[str] = Field(
        default_factory=list, description="E.g., limestone, granite"
    )
    extraction_notes: str = Field(default="", description="Notes about the extraction process")


class TypeClusterProposal(BaseModel):
    """LLM proposal for a typological cluster."""

    typology_label: str = Field(description="Typology category name")
    member_uris: list[str] = Field(description="URIs of typologically similar entities")
    defining_features: list[str] = Field(description="Features that define this typology")
    reasoning: str = Field(description="Explanation of the typological grouping")
    llm_confidence: float = Field(ge=0.0, le=1.0)


class SimilarityPairProposal(BaseModel):
    """LLM proposal for a similarTo relation."""

    source_uri: str = Field(description="URI of the first site")
    target_uri: str = Field(description="URI of the second site")
    shared_features: list[str] = Field(description="Features shared by both sites")
    reasoning: str = Field(description="Why these sites are considered similar")
    llm_confidence: float = Field(ge=0.0, le=1.0)


class TypologicalAnalysisResponse(BaseModel):
    """Complete structured response from TypologicalAgent LLM call."""

    feature_extractions: list[ExtractedFeatures] = Field(
        default_factory=list, description="Feature extractions per entity"
    )
    clusters: list[TypeClusterProposal] = Field(
        default_factory=list, description="Typological clusters"
    )
    similarity_pairs: list[SimilarityPairProposal] = Field(
        default_factory=list, description="Similarity relations"
    )
    typological_observations: str = Field(
        default="", description="General typological observations"
    )


class PathStopProposal(BaseModel):
    """LLM proposal for a stop in a thematic path."""

    site_uri: str = Field(description="URI of the site")
    site_name: str = Field(description="Display name for the site")
    order: int = Field(ge=1, description="Order in the path")
    narrative: str = Field(description="Narrative for the visitor at this stop")
    visit_duration_minutes: int = Field(default=30, description="Suggested visit duration")


class ThematicPathProposal(BaseModel):
    """LLM proposal for a complete thematic path."""

    path_title: str = Field(description="Title of the thematic path")
    theme: str = Field(description="Theme: geographic, chronological, typological, or mixed")
    path_type: str = Field(
        description="Path type determines validation. MUST be one of: "
        "'geographic' (strict distance limits, max 200km - use when proximity dominates), "
        "'chronological' (flexible - use when a shared period dominates), "
        "'typological' (flexible - use when shared architectural/functional type dominates), "
        "'mixed' (flexible - use ONLY when no single criterion dominates)",
    )
    stops: list[PathStopProposal] = Field(description="Ordered list of stops")
    overall_narrative: str = Field(description="Introduction and overall narrative for the path")
    estimated_duration_hours: float = Field(ge=0.5, description="Total estimated duration")
    difficulty: str = Field(default="medium", description="Path difficulty: easy, medium, hard")
    reasoning: str = Field(description="Why this path was designed this way")
    llm_confidence: float = Field(ge=0.0, le=1.0)


class NarrativeAnalysisResponse(BaseModel):
    """Complete structured response from NarrativeAgent LLM call."""

    paths: list[ThematicPathProposal] = Field(
        default_factory=list, description="Proposed thematic paths"
    )
    site_descriptions: dict[str, str] = Field(
        default_factory=dict, description="Enhanced descriptions per site URI"
    )
    overall_narrative: str = Field(
        default="", description="Overall narrative about the site collection"
    )
